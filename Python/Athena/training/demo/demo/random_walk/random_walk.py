""" A demonstration of computing a random walk using numpy and scipy.  The
    random walk is a Wiener process (i.e. Brownian motion).  When this program
    is run, two random walks are generated, one using an explicit python loop,
    and one using numpy.cumsum to create the values in the random walk.  The
    time required for each version is printed, and the random walks are plotted.
"""

import time
import numpy
from math import sqrt
from scipy.stats import norm
from pylab import plot, show, grid, xlabel, ylabel



def random_walk(x0, n, dt, delta):
    """Generate a one-dimensional random walk.
    
    The array of values generated by this function simulate a Wiener process.
    
    Arguments
    ---------    
    x0 : float
        The starting point of the random walk.
    n : int
        The number of steps to take.
    dt : float
        The time step.
    delta : float
        delta determines the "speed" of the random walk.  The random variable
        of the position at time t, X(t), has a normal distribution whose mean
        is the position at time t=0 and whose variance is delta**2*t.
        
    Returns
    -------
    random_walk() returns a one-dimensional numpy array of floats with
    length n+1.  The first element in the array is x0, and the k-th element
    is x(k*dt).
    """

    # Generate a sample of n+1 numbers from a normal distribution.
    r = norm.rvs(size=(n+1,), scale=delta*sqrt(dt))
    # Replace the first element with 0.0, so that x0 + r.cumsum() results
    # in the first element being x0.
    r[0] = 0.0
    # This computes the random walk by forming the cumulative sum of
    # the random sample. 
    x = x0 + r.cumsum()
    return x


def random_walk_loop(x0, n, dt, delta):
    """Generate a one-dimensional random walk (slow version!).
    
    This function has the same arguments and return value as random_walk().
    It uses an explicit loop in which a random number is generated and
    added to the current position, so it is much slower than random_walk().
    """

    c = delta*sqrt(dt)
    x = numpy.empty((n+1,))
    x[0] = x0
    for k in range(1,n+1):
        x[k] = x[k-1] + norm.rvs(scale=c)
    return x


def main():
    # The Wiener process parameter.
    delta = 2
    # Total time.
    T = 10.0
    # Number of steps.
    N = 1000
    # Time step size
    dt = T/N
    # Initial value of x.
    x0 = 100.0

    time0 = time.time()
    xa = random_walk(x0, N, dt, delta)
    time1 = time.time()
    xb = random_walk_loop(x0, N, dt, delta)
    time2 = time.time()

    print "numpy cumsum: %.3g seconds" % (time1-time0)
    print "python loop:  %.3g seconds" % (time2-time1)
    print "ratio: %.2f" % ((time2-time1)/(time1-time0))

    t = numpy.linspace(0.0, N*dt, N+1)
    plot(t, xa, 'g')
    plot(t, xb, 'b')
    xlabel('t', fontsize=16)
    ylabel('x',fontsize=16)
    grid(True)
    show()


if __name__ == "__main__":
    main()
