<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<style type="text/css">

/* example stylesheet for Docutils */

/* :Author:    Günter Milde */
/* :Copyright: © 2012 G. Milde */
/* :License:   This stylesheet is placed in the public domain. */

/* Syntax highlight rules for HTML documents generated with Docutils */
/* using the ``--syntax-highlight=long`` option (new in v. 0.9). */

/* This stylesheet implements Pygment's "default" style with less rules than */
/* pygments-default using class hierarchies.                                 */
/* Use it as example for "handcrafted" styles with only few rules.      */

.code                              { background: #f8f8f8; }
.code .comment                     { color: #008800; font-style: italic }
.code .error                       { border: 1px solid #FF0000 }
.code .generic.deleted             { color: #A00000 }
.code .generic.emph                { font-style: italic }
.code .generic.error               { color: #FF0000 }
.code .generic.heading             { color: #000080; font-weight: bold }
.code .generic.inserted            { color: #00A000 }
.code .generic.output              { color: #808080 }
.code .generic.prompt              { color: #000080; font-weight: bold }
.code .generic.strong              { font-weight: bold }
.code .generic.subheading          { color: #800080; font-weight: bold }
.code .generic.traceback           { color: #0040D0 }
.code .keyword                     { color: #AA22FF; font-weight: bold }
.code .keyword.pseudo              { font-weight: normal }
.code .literal.number              { color: #666666 }
.code .literal.string              { color: #BB4444 }
.code .literal.string.doc          { color: #BB4444; font-style: italic }
.code .literal.string.escape       { color: #BB6622; font-weight: bold }
.code .literal.string.interpol     { color: #BB6688; font-weight: bold }
.code .literal.string.other        { color: #008000 }
.code .literal.string.regex        { color: #BB6688 }
.code .literal.string.symbol       { color: #B8860B }
.code .name.attribute              { color: #BB4444 }
.code .name.builtin                { color: #AA22FF }
.code .name.class                  { color: #0000FF }
.code .name.constant               { color: #880000 }
.code .name.decorator              { color: #AA22FF }
.code .name.entity                 { color: #999999; font-weight: bold }
.code .name.exception              { color: #D2413A; font-weight: bold }
.code .name.function               { color: #00A000 }
.code .name.label                  { color: #A0A000 }
.code .name.namespace              { color: #0000FF; font-weight: bold }
.code .name.tag                    { color: #008000; font-weight: bold }
.code .name.variable               { color: #B8860B }
.code .operator                    { color: #666666 }
.code .operator.word               { color: #AA22FF; font-weight: bold }

</style>
<style type="text/css">

/* Page layout tweaks */
div.document { width: 6in; }

</style>
<style type="text/css">

/*
*   math2html: convert LaTeX equations to HTML output.
*
*   Copyright (C) 2009,2010 Alex Fernández
*
*   Released under the terms of the `2-Clause BSD license'_, in short:
*   Copying and distribution of this file, with or without modification,
*   are permitted in any medium without royalty provided the copyright
*   notice and this notice are preserved.
*   This file is offered as-is, without any warranty.
*
* .. _2-Clause BSD license: http://www.spdx.org/licenses/BSD-2-Clause
*
*   Based on eLyXer: convert LyX source files to HTML output.
*   http://elyxer.nongnu.org/
*/
/* --end--
* CSS file for LaTeX formulas.
*/

/* Formulas */
.formula {
	text-align: center;
	font-family: "Droid Serif", "DejaVu Serif", "STIX", serif;
	margin: 1.2em 0;
}
span.formula {
	white-space: nowrap;
}
div.formula {
	padding: 0.5ex;
	margin-left: auto;
	margin-right: auto;
}

/* Basic features */
a.eqnumber {
	display: inline-block;
	float: right;
	clear: right;
	font-weight: bold;
}
span.unknown {
	color: #800000;
}
span.ignored, span.arraydef {
	display: none;
}
.formula i {
	letter-spacing: 0.1ex;
}

/* Alignment */
.align-left, .align-l {
	text-align: left;
}
.align-right, .align-r {
	text-align: right;
}
.align-center, .align-c {
	text-align: center;
}

/* Structures */
span.overline, span.bar {
	text-decoration: overline;
}
.fraction, .fullfraction {
	display: inline-block;
	vertical-align: middle;
	text-align: center;
}
.fraction .fraction {
	font-size: 80%;
	line-height: 100%;
}
span.numerator {
	display: block;
}
span.denominator {
	display: block;
	padding: 0ex;
	border-top: thin solid;
}
sup.numerator, sup.unit {
	font-size: 70%;
	vertical-align: 80%;
}
sub.denominator, sub.unit {
	font-size: 70%;
	vertical-align: -20%;
}
span.sqrt {
	display: inline-block;
	vertical-align: middle;
	padding: 0.1ex;
}
sup.root {
	font-size: 70%;
	position: relative;
	left: 1.4ex;
}
span.radical {
	display: inline-block;
	padding: 0ex;
	font-size: 150%;
	vertical-align: top;
}
span.root {
	display: inline-block;
	border-top: thin solid;
	padding: 0ex;
	vertical-align: middle;
}
span.symbol {
	line-height: 125%;
	font-size: 125%;
}
span.bigsymbol {
	line-height: 150%;
	font-size: 150%;
}
span.largesymbol {
	font-size: 175%;
}
span.hugesymbol {
	font-size: 200%;
}
span.scripts {
	display: inline-table;
	vertical-align: middle;
}
.script {
	display: table-row;
	text-align: left;
	line-height: 150%;
}
span.limits {
	display: inline-table;
	vertical-align: middle;
}
.limit {
	display: table-row;
	line-height: 99%;
}
sup.limit, sub.limit {
	line-height: 100%;
}
span.symbolover {
	display: inline-block;
	text-align: center;
	position: relative;
	float: right;
	right: 100%;
	bottom: 0.5em;
	width: 0px;
}
span.withsymbol {
	display: inline-block;
}
span.symbolunder {
	display: inline-block;
	text-align: center;
	position: relative;
	float: right;
	right: 80%;
	top: 0.3em;
	width: 0px;
}

/* Environments */
span.array, span.bracketcases, span.binomial, span.environment {
	display: inline-table;
	text-align: center;
	border-collapse: collapse;
	margin: 0em;
	vertical-align: middle;
}
span.arrayrow, span.binomrow {
	display: table-row;
	padding: 0ex;
	border: 0ex;
}
span.arraycell, span.bracket, span.case, span.binomcell, span.environmentcell {
	display: table-cell;
	padding: 0ex 0.2ex;
	line-height: 99%;
	border: 0ex;
}
/*
* CSS file for LaTeX formulas, extra stuff:
* binomials, vertical braces, stackrel, fonts and colors.
*/

/* Inline binomials */
span.binom {
	display: inline-block;
	vertical-align: middle;
	text-align: center;
	font-size: 80%;
}
span.binomstack {
	display: block;
	padding: 0em;
}

/* Over- and underbraces */
span.overbrace {
	border-top: 2pt solid;
}
span.underbrace {
	border-bottom: 2pt solid;
}

/* Stackrel */
span.stackrel {
	display: inline-block;
	text-align: center;
}
span.upstackrel {
	display: block;
	padding: 0em;
	font-size: 80%;
	line-height: 64%;
	position: relative;
	top: 0.15em;

}
span.downstackrel {
	display: block;
	vertical-align: bottom;
	padding: 0em;
}

/* Fonts */
span.mathsf, span.textsf {
	font-style: normal;
	font-family: sans-serif;
}
span.mathrm, span.textrm {
	font-style: normal;
	font-family: serif;
}
span.text, span.textnormal {
	font-style: normal;
}
span.textipa {
	color: #008080;
}
span.fraktur {
	font-family: "Lucida Blackletter", eufm10, blackletter;
}
span.blackboard {
	font-family: Blackboard, msbm10, serif;
}
span.scriptfont {
	font-family: "Monotype Corsiva", "Apple Chancery", "URW Chancery L", cursive;
	font-style: italic;
}

/* Colors */
span.colorbox {
	display: inline-block;
	padding: 5px;
}
span.fbox {
	display: inline-block;
	border: thin solid black;
	padding: 2px;
}
span.boxed, span.framebox {
	display: inline-block;
	border: thin solid black;
	padding: 5px;
}


</style>
</head>
<body>
<div class="document">


<!-- #!/usr/bin/env python3 -->
<div class="section" id="case-study">
<h1>χ² Case Study</h1>
<p>This is a case study of using χ² in an EDA context.
See  <a class="reference external" href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm</a></p>
<p>Here's the background information from this example:</p>
<blockquote>
A total of 309 wafer defects were recorded and the defects
were classified as being one of four types, A, B, C, or D.
At the same time each wafer was identified according to
the production shift in which it was manufactured, 1, 2, or 3.</blockquote>
<p>We have a table of defects by shift and type. Each row is a different
shift, each column is a different type.</p>
<pre class="literal-block">
defects = [
    [15, 21, 45, 13],
    [26, 31, 34,  5],
    [33, 17, 49, 20],
]
</pre>
<p>We can imagine this is the result of summarizing raw data.
The raw data migth look like this:</p>
<pre class="literal-block">
shift,defect,serial
1,None,12345
1,None,12346
1,A,12347
1,B,12348
<em>etc.</em> for thousands of wafers
</pre>
<p>The summary table is the result of something like a
<tt class="docutils literal">collections.Counter()</tt> using <tt class="docutils literal">shift,defect</tt> as the key.</p>
<p>Or perhaps the results come from a SQL query like this:</p>
<pre class="literal-block">
SELECT SHIFT, DEFECT, COUNT(*) FROM some tables
...
GROUP BY SHIFT, DEFECT
HAVING DEFECT NOT NULL;
</pre>
<p>Before starting the analysis, we'll need to import some libraries</p>
<pre class="literal-block">
from chi_sq import cdf
from fractions import Fraction
</pre>
<div class="section" id="basic-eda-analysis">
<h2>Basic EDA Analysis</h2>
<p>We need to see if the effects are random or not. If the effects are
random variation, our hypothesis is that there's nothing to see
here. This is the statistician's &quot;null hypothesis:&quot; nothing interesting
is happening.</p>
<p>To evaluate the null hypothesis, we compare the observed defect
data against some reasonable expectations for the defect data.</p>
<p>What we'll do is determine a hypothetical allocation of the
same total number of defects that has a similar distribution
based on shift and type.</p>
<p>The total number of defects is <span class="formula"><span class="limits"><span class="limit"><span class="symbol">∑</span></span></span><sub><i>s</i></sub><span class="limits"><span class="limit"><span class="symbol">∑</span></span></span><sub><i>t</i></sub><i>d</i><sub><i>s</i>, <i>t</i></sub> = 309</span>
.</p>
<pre class="literal-block">
total= sum( map(sum, defects) )
</pre>
<p>We need to compute expected defects by shift and type.
The null hypothesis asserts that all effects are random,
so the efects should be evenly spread across shift and type.</p>
</div>
<div class="section" id="defects-by-shift">
<h2>Defects By Shift</h2>
<p>The shift totals are defined as <span class="formula">{<span class="limits"><span class="limit"><span class="symbol">∑</span></span></span><sub><i>t</i></sub><i>d</i><sub><i>st</i></sub><span class="bigsymbol">∣</span>0 ≤ <i>s</i> &lt; 3}</span>
.</p>
<pre class="literal-block">
shift_total = [sum(defects[s][t] for t in range(4)) for s in range(3)]
</pre>
<p>The total number of defects by shift are <tt class="docutils literal">[94, 96, 119]</tt>.</p>
<p>We can also calculate the totals like this, but that doesn't generalize well
to for computing sum across types.</p>
<pre class="literal-block">
list( map(sum, defects) )
</pre>
<p>Here are the probabilities of a defect based on actual counts
of defects by shift.</p>
<pre class="literal-block">
P_shift = [Fraction(s,total) for s in shift_total]
</pre>
<p>We get this as a value <tt class="docutils literal">[Fraction(94, 309), Fraction(32, 103), Fraction(119, 309)]</tt>.</p>
<p>We've materialized two list objects here. Since we'll be producing some
intermediate output, the materialized collections are helpful.
If we did not intend to produce intermediate output, we could use
lazy generator functions to reduce the amount of memory required.</p>
</div>
<div class="section" id="defects-by-type">
<h2>Defects By Type</h2>
<p>Computing the type totals isn't quite so simple as computing the
shift totals because we're slicing the matrix on an axis that doesn't
work trivially with the <tt class="docutils literal">sum()</tt> function.</p>
<p>Here are the type totals: <span class="formula">{<span class="limits"><span class="limit"><span class="symbol">∑</span></span></span><sub><i>s</i></sub><i>d</i><sub><i>st</i></sub><span class="bigsymbol">∣</span>0 ≤ <i>t</i> &lt; 4}</span>
.</p>
<pre class="literal-block">
type_total = [sum(shift[t] for shift in defects) for t in range(4)]
</pre>
<p>The values are <tt class="docutils literal">[74, 69, 128, 38]</tt>.</p>
<p>Here are the probabilities of a defect based on actual counts
of defects by type.</p>
<pre class="literal-block">
P_type = [Fraction(t,total) for t in type_total]
</pre>
<p>The values are <tt class="docutils literal">[Fraction(74, 309), Fraction(23, 103), Fraction(128, 309), Fraction(38, 309)]</tt>.</p>
</div>
<div class="section" id="combined-expectations">
<h2>Combined Expectations</h2>
<p>The overall defect probabilities
are <span class="formula"><i>P</i><sub><i>ij</i></sub> = <i>Ps</i><sub><i>s</i></sub> × <i>Pt</i><sub><i>t</i></sub></span>
 for each shift
and type. This reflects the null hypothesis that neither shift nor type
of defect has any bearing on the values: they're all just random.</p>
<p>We can multiplie the probability by the total number of defects to compute
how many defects belong to each combination of shift and type.</p>
<pre class="literal-block">
expected = [
    [float(ps*pt)*total for pt in P_type]
    for ps in P_shift
]
</pre>
<p>We can format these results like this to make something understandable:</p>
<pre class="literal-block">
r2=lambda x:round(x,2)
list( list(map(r2,row)) for row in expected )
</pre>
<p>We have following expected values for defect counts</p>
<pre class="literal-block">
[
   [22.51, 20.99, 38.94, 11.56],
   [22.99, 21.44, 39.77, 11.81],
   [28.5, 26.57, 49.29, 14.63]
]
</pre>
<p>Each cell is based on a contribution of shift and type to the overall
number of defects.</p>
<p>Note the imporant difference from the expectation that the number of defects
would be <span class="formula"><span class="fraction"><span class="ignored">(</span><span class="numerator">309</span><span class="ignored">)/(</span><span class="denominator">12</span><span class="ignored">)</span></span> = 25.75</span>
 in all cases. We're not asserting
that shift and type of defect have no effect. We're asserting that the
effects are independent of each other.</p>
<p>For example, the different shifts may have different numbers of workers.
It might be perfectly reasonable for one shift to produce more wafers
and therefore more defects. Using actual shift totals to compute
the probabilities reflects the idea that the observed counts will vary.</p>
</div>
<div class="section" id="displaying-the-contingency-table">
<h2>Displaying the Contingency Table</h2>
<p>We can display the observed and expected
in a single table. This involves a bit of restructuring the data
to show defects and expected values side-by-side.</p>
<pre class="literal-block">
print( &quot;obs exp    &quot;*4 )
for s in range(3):
    pairs= [&quot;{0:3d} {1:5.2f}&quot;.format(
        defects[s][t], expected[s][t] ) for t in range(4)]
    print( &quot;{0}  {1}  {2}  {3}  {total:3d}&quot;.format(
        *pairs, total=shift_total[s])  )
print( &quot;{0:3d}        {1:3d}        {2:3d}        {3:3d}        {total:3d}&quot;.format(
    *type_total, total=total) )
</pre>
<p>For each of the three shifts, we produced a row of data.
Each row was pairs of observed and expected organized by defect
type.</p>
<p>The output looks like this:</p>
<pre class="literal-block">
obs exp    obs exp    obs exp    obs exp
 15 22.51   21 20.99   45 38.94   13 11.56   94
 26 22.99   31 21.44   34 39.77    5 11.81   96
 33 28.50   17 26.57   49 49.29   20 14.63  119
 74         69        128         38        309
</pre>
<p>This shows the observed defects and the expected defects.
It shows the shift totals and the defect type totals, also.</p>
<p>In many practical applications, producing a text report like this
isn't really optimal. It's often nicer to write a CSV file that
can be reformatted for display. Using tools like Pandas xlsx writer
can provide more useful output.</p>
<p>Here's the CSV version of the output. It requires a function
to properly flatten and interleave defects and expected values.</p>
<pre class="literal-block">
def flatten( defects, expected=None ):
    for t in range(4):
        yield defects[t]
        if expected:
            yield expected[t]
        else:
            yield None
</pre>
<p>This is similar in philosophy to the <tt class="docutils literal">itertools.zip_longest()</tt> function.
It interleaves values from defects and an optional second iterable.
It can also be used to emit headers and footers; these situations don't
have both iterables.</p>
<pre class="literal-block">
import csv

with open(&quot;contigency.csv&quot;,&quot;w&quot;,newline=&quot;&quot;) as output:
    wtr=csv.writer(output)
    wtr.writerow([&quot;shift&quot;]+list(flatten((&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;)))+[&quot;total&quot;])
    wtr.writerow([&quot;&quot;,&quot;obs&quot;,&quot;exp&quot;,&quot;obs&quot;,&quot;exp&quot;,&quot;obs&quot;,&quot;exp&quot;,&quot;obs&quot;,&quot;exp&quot;])
    for s in range(3):
        row= [s]+list(flatten(defects[s],expected[s]))+[shift_total[s]]
        wtr.writerow(row)
    row= [&quot;total&quot;]+list(flatten(type_total))+[total]
    wtr.writerow(row)
</pre>
<p>We've opened a writer and put out two lines of titles as a heading.
The <tt class="docutils literal"><span class="pre">list(flatten((&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;)))</span></tt> produces eight values by
interleaving the four defect types and an equal number of <tt class="docutils literal">None</tt> values.</p>
<p>The body includes the interleaved defect counts and expected counts. Each
row has a shift number as a header and a shift total as a summary.</p>
<p>The total line uses <tt class="docutils literal">list(flatten(type_total))</tt> to interleave the
defect type totals with None values to create a footer line.</p>
<p>Based on the totals, the third shift is expected to be more productive
than the first two. Similarly, defect type &quot;C&quot; is expected to show up
considerably more often than defect type &quot;D&quot;.</p>
<p>The question is &quot;do the cell details reflect the overall summaries?&quot;</p>
</div>
<div class="section" id="applying-the-2-test">
<h2>Applying the χ² test</h2>
<p>The final χ² value involves <span class="formula"><span class="limits"><span class="limit"><span class="symbol">∑</span></span></span><sub><i>s</i></sub><span class="limits"><span class="limit"><span class="symbol">∑</span></span></span><sub><i>t</i></sub><span class="fraction"><span class="ignored">(</span><span class="numerator">(<i>E</i><sub><i>st</i></sub> − <i>d</i><sub><i>st</i></sub>)<sup>2</sup></span><span class="ignored">)/(</span><span class="denominator"><i>E</i><sub><i>st</i></sub></span><span class="ignored">)</span></span></span>
</p>
<p>We have three broad design patterns for workting with parallel nested structures:</p>
<ol class="arabic simple">
<li>Sum of sums. This involves a <tt class="docutils literal">sum( map( sum, iterable ) )</tt> expression.
Since we have two structures that must be compared, this is really a bit
more complex than it appears. We need to compute the differences
before summing.</li>
<li>Use all combinations of index values.</li>
<li>Flatten both expected and actual and use a single sum.</li>
</ol>
<p>The second approach is how we produced the contingency table, above.</p>
<p>We'll look at the third approach, also.</p>
<p>Both will benefit from a handy lambda that allows us to compute the squared
difference value between expected, <tt class="docutils literal">e</tt>, and observed, <tt class="docutils literal">o</tt>.</p>
<pre class="literal-block">
diff= lambda e,o: (e-o)**2/e
</pre>
<p>We can use this lambda with all combinations of indices like this.</p>
<pre class="literal-block">
chi2= sum(diff(expected[s][t], defects[s][t])
    for s in range(3)
        for t in range(4)
        )
</pre>
<p>We can also apply this lambda to two flattened sequences like this:</p>
<pre class="literal-block">
chi2= sum( map( diff,
    (e for shift in expected for e in shift),
    (o for shift in defects for o in shift),
    ) )
</pre>
<p>Either version gets us a χ² value, <tt class="docutils literal">chi2</tt>, of 19.18. There are six degrees
of freedom in this model: 3-1=2 shifts times 4-1=3 types.</p>
<pre class="literal-block">
print( &quot;χ² = {0:.2f}, P = {1:.5f}&quot;.format(chi2, cdf(chi2, 6) ) )
</pre>
<p>The output looks like this:</p>
<pre class="literal-block">
χ² = 19.18, P = 0.00387
</pre>
<p>The probability of this data being random is very low. There's something
going on here that deserves further investigation. In formal terms,
we must reject the null hypothesis.</p>
</div>
</div>
<div class="section" id="functional-python-notes">
<h1>Functional Python Notes</h1>
<p>Generally, each step has been defined by functional programming design
patterns. We've accumulated totals, transformed them to probabilities,
and then transformed the probabilities into expected values.
We computed the χ² and compared this with the χ² cumulative distribution
function to measure the randomness of the data.</p>
<p>Each stage has been done with generator expressions and higher-order
functions.</p>
<p>In order to produce a printed report or CSV output file, we had to
step back from purely functional programming. In these two cases,
we used Python imperative programming techniques to structure
the output in the intended format.</p>
</div>
</div>
</body>
</html>
